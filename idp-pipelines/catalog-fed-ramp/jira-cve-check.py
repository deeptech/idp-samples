import argparse
import json
from datetime import datetime, timezone
from common import updateCatalogAttributes, determine_catalog_path
import os
import re
import argparse
import sys
import requests
import yaml
import base64



def fetch_jql_query(base_path: str, service: str):
    """
    Determine the jql queries

    :param base_path (str): Base path of the folder containing the service repo
    :param service (str): The name of the repo or service
    :return:
        jira_project_key
        jql_warn_query
        jql_fail_query
    """
    try:
        # Construct the file path

        file_path = determine_catalog_path(base_path, service)

        print(f" Inspecting catalog file at {file_path}")

        # Check if the file exists
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"File {file_path} not found.")

        # Open and read the YAML file
        with open(file_path, "r") as file:
            data = yaml.safe_load(file)

        default_warn_jql = 'project = <<projectKey>> AND type = CVE AND "CVE SLA: Due date[Date]" >= endOfDay() AND "CVE SLA: Due date[Date]" <= 5d AND statusCategory != Done'
        default_fail_jql = 'project = <<projectKey>> and type = CVE and "CVE SLA: Due date[Date]" < endOfDay() AND statusCategory != Done'

        jira_project_key = (
            data.get("metadata", {})
            .get("annotations", {})
            .get("jira/project-key", None)
        )
        jql_warn_query = (
            data.get("metadata", {})
            .get("annotations", {})
            .get("acme/cve-warn", default_warn_jql)
        )
        jql_fail_query = (
            data.get("metadata", {})
            .get("annotations", {})
            .get("acme/cve-fail", default_fail_jql)
        )

        return jira_project_key, jql_warn_query, jql_fail_query

    except FileNotFoundError as fnf_error:
        print(f"{fnf_error}")
        return str(fnf_error)  # Return error message if file is not found
    except yaml.YAMLError as yaml_error:
        print(f"{yaml_error}")
        return f"Error reading YAML file: {yaml_error}"


def request_jira(jql: str, jira_url: str, username: str, api_token: str):
    """
    Invoke post to jira to determine response count
    :param jql(str): jql query
    :param jira_url(str): URL to jira
    :param username(str): email
    :param api_token(str): jira token

    :return: String holding configured relative path
    """
    response = query_jira(jql, jira_url, username, api_token)

    if response:
        issue_count = response.get("total", 0)
        return issue_count

    else:
        print("Failed to retrieve Jira issues.")
        raise ValueError("No Count returns for query")


def replace_jql_placeholders(jql: str, replacements: str):
    """
    Insert values into place holders
    :param jql(str): jql query
    :param replacements(str): replacement values
     :return: String with new jql
    """
    for placeholder, value in replacements.items():
        jql = jql.replace(f"<<{placeholder}>>", value)
    return jql


def query_jira(jql: str, jira_url: str, username: str, api_token: str):
    """
    Query jira via api
    :param jql(str):  query
    :param username(str): email
    :param api_token(str): token
    :return: Response object
    """
    # Define the endpoint and headers
    endpoint = f"{jira_url}/rest/api/3/search"
    headers = {"Content-Type": "application/json"}

    # Define the payload
    payload = {"jql": jql, "maxResults": 50}  # Limit results (adjust as needed)

    # Make the request
    try:
        response = requests.post(
            endpoint, json=payload, auth=(username, api_token), headers=headers
        )

        # Check for errors
        response.raise_for_status()  # Raises an HTTPError for bad responses (4xx or 5xx)
        return response.json()

    except requests.exceptions.RequestException as e:
        print(f"Error querying Jira API: {e}")
        return None


def main():
    # Set up argument parser
    parser = argparse.ArgumentParser(description="CVE checks")

    parser.add_argument(
        "--base_dir", type=str, help="Path to infra", default="/harness/harness-infra"
    )

    parser.add_argument("--jira_api_key", type=str, help="jira api key")

    parser.add_argument("--jira_url", type=str, help="jira url")

    parser.add_argument("--jira_user_name", type=str, help="jira user_name")

    parser.add_argument("--harness_api_token", type=str, help="API Token")

    parser.add_argument("--harness_account_id", type=str, help="Harness Account ID")

    parser.add_argument("--servicename", type=str, help="service repo name")

    parser.add_argument("--base_path", type=str, help="basepath of checked out code", default="/harness")
    

    args = parser.parse_args()

    harness_account_id = args.harness_account_id
    harness_api_token = args.harness_api_token
    jira_api_token = args.jira_api_key
    username = args.jira_user_name
    jira_url = args.jira_url
    base_dir = args.base_path
    servicename = args.servicename


    jira_project_key, jql_warn_query, jql_fail_query = fetch_jql_query(
        base_dir, servicename
    )
    catalog_entity = f"component:default/{servicename}"

    dynamic_values = {
        "projectKey": jira_project_key,
    }

    dynamic_fail_jql = replace_jql_placeholders(jql_fail_query, dynamic_values)
    dynamic_warn_jql = replace_jql_placeholders(jql_warn_query, dynamic_values)

    print(f"Processing {catalog_entity}")
    print(f"    jira_project_key: {jira_project_key}")
    print(f"    dynamic_fail_jql: {dynamic_fail_jql}")
    print(f"    dynamic_warn_jql: {dynamic_warn_jql}")

    try:
        service_fail_count = request_jira(
            dynamic_fail_jql, jira_url, username, jira_api_token
        )
        service_warn_count = request_jira(
            dynamic_warn_jql, jira_url, username, jira_api_token
        )
        print(f"   fail {service_fail_count} : {dynamic_fail_jql}")
        print(f"   warn {service_warn_count} : {dynamic_warn_jql}")

        if service_fail_count != None and service_warn_count != None:
            print("Updating catalog attributes")

            properties_array = [
                {
                    "property": "metadata.cve.fail",
                    "value": service_fail_count
                },
                {
                    "property": "metadata.cve.warn",
                    "value": service_warn_count,
                }
            ]

            updateResultFlag = updateCatalogAttributes(
                harness_account_id,
                harness_api_token,
                catalog_entity,
                "metadata.cve",
                properties_array,
            )

            if (updateResultFlag==False):
                 raise ValueError("Failed to update catalog")


            print("\n")

    except Exception as e:
        print(f"{e}")
        print("Exiting utility due to fatal error")
        sys.exit(1)


if __name__ == "__main__":
    main()
